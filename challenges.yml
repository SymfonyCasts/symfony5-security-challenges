make_user_2a:
  question: |
    Your "user" class can be called whatever you want... and *look* however you want... as
    long as it implements `UserInterface`. In Symfony 6, what info does `UserInterface` require
    your "user" class to provide?
  explanation: |
    In Symfony 6, the interface will only require `getUserIdentifier()`, `getRoles()` and
    `eraseCredentials()`. In this tutorial we DO have the other methods on `User`, but
    only because they're deprecated... and in Symfony 6 you CAN still have a "hashed password",
    but only if you need it. For the purposes of this question, I'm ignoring `eraseCredentials()`
    because it doesn't "provide" any information.
  features:
    multiple_choice:
      choices:
        a: |
          `UserInterface` requires your user to have a "user identifier" and an array of "roles".
        b: |
          `UserInterface` requires your user to have a "user identifier", an array of "roles"
          and a "hashed password".
        c: |
          `UserInterface` requires your user to have a "username", "user identifier", an array
          of "roles" and a "hashed password".
      correct: a

make_user_2b:
  question: |
    Does your `User` class need to be a Doctrine entity?
  explanation: |
    Here, we should explain that if your `User` class is NOT a Doctrine entity, then `make:user`
    would generate a custom "user provider" class where you would need to do some manual work.
    If you use an entity, you get to use the built-in entity provider that we see in
    `security.yaml`.
  features:
    multiple_choice:
      choices:
        a: |
          Technically no, but you'll need to create your own authenticator system to support
          a non-entity `User` class.
        b: |
          No: you're free to make your `User` class a Doctrine entity or not.
        c: |
          Yes. But it's no problem: if you load users data from somewhere else (e.g. an API),
          just store a local "cache" of that data in your local database.
      correct: b

firewalls_authenticator_5:
  question: |
    Check out the following firewalls setup in `security.yaml`:

    ```yaml
    security:
        # ...
        firewalls:
            main_firewall:
                pattern: ^/api/
                # ...
                custom_authenticator: App\Security\MainApiAuthenticator

            products_firewall:
                pattern: ^/api/product
                # ...
                custom_authenticator: App\Security\ProductApiAuthenticator
    ```

    If I make a request to `/api/product`, which authenticators will be executed?
  explanation: |
    The explanation here is mostly that... this is terrible example! First, yes, only 1 firewall
    is EVER active on a request, and it figures it out by starting from the top and finding
    the FIRST firewall that matches the URL. But more importantly, it almost never makes sense
    to have two firewalls.... even if you have two different ways to authenticate. This should
    be moved to one firewall. The exception to that rule is if you have, for example, a frontend
    that has one `User` class and an API under `/api/` where, if you log in, you will be logged
    in as a completely different user class - e.g. `ApiUser`.
  features:
    multiple_choice:
      choices:
        a: |
          Both authenticators will be executed because both firwalls match the current URL
          and will be activated.
        b: |
          Only `MainApiAuthenticator` will be executed because that one firewall matches first.
        c: |
          Only `ProductApiAuthenticator` will be executed because its firewall matches closer
          and will be executed first.
      correct: b

passport_6:
  question: |
    We know that the `supports()` method in an authenticator is called at the start of *every*
    single request. What happens if we return `false` from this method?
  features:
    multiple_choice:
      choices:
        a: |
          The request continues like normal and the controller for that page is executed.
        b: |
          Authentication fails & the `onAuthenticationFailure()` method is called.
        c: |
          The `supports()` method on any other authenticators is called. And if all of those
          return `false`, access is denied.
      correct: a

success_user_provider_8:
  question: |
    In our app, we're using the `entity` user provider:

    ```yaml
    security
        # ...
        providers:
            app_user_provider:
                entity:
                    class: App\Entity\User
                    property: email
    ```

    In theory, could we design a security system that *never* actually *called* any methods
    on our user provider?
  explanation: |
    First, yes, you DO need to configure the `providers` key in `security.yaml`. But
    whether or not any methods are actually called on it depends on your app. Your
    user provider is called in two main situations:

    1. To load the user in your authenticator (unless you pass a custom user loader function).
    2. To refresh the user at the start of your request (unless you set `stateless: true`
       for your firewall, which you can do for API-only apps).

    So, in just the right situation, your user loader will never be called.

    But the user provider will *also* be called if you use certain features, like
    `remember_me` or `switch_user`.

    TL;DR You probably need a user provider, but it does mostly boring background work for us.
  features:
    multiple_choice:
      choices:
        a: |
          Yes: If you used a "stateless" firewall (one that doesn't store the user in the
          session between requests) and passed a custom user loader in your authenticator
          (like we are).
        b: |
          No: At the very least, the user provider is needed to "refresh" the user on every
          request.
        c: |
          No: The user provider is used in various spots. For example, the web debug toolbar
          uses it to tell us who is logged in.
      correct: a

auth_errors_9:
  question: |
    Check out this code in our authenticator:

    ```php
    public function authenticate(Request $request): Passport
    {
        $email = $request->request->get('email');
        $password = $request->request->get('password');

        if ($email === 'ryan@symfonycasts.com') {
            throw new UserNotFoundException('Get outta here Ryan!');
        }

        return new Passport(new UserBadge($email), new PasswordCredentials($passowrd));
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): Response
    {
        dd($exception);
    }
    ```

    If I try to login as `ryan@symfonycasts.com`, what type of object will be dumped inside
    `onAuthenticationFailure()`? And if we redirected to `/login` and rendered that error,
    what text would be displayed?
  explanation: |
    This is a fun one! First, it's legal to throw an `AuthenticationException` (or sub-class)
    from *anywhere* during the authentication process. So throwing this exception directly
    in `authenticate()` is just fine.

    Next, whatever exception you throw is directly passed to `onAuthenticationFailure()`.
    The only exception to that rule is `UserNotFoundException`, which *may* or may not be
    converted to a `BadCredentialsException`, depending on your config.

    Finally, you *are* free to pass a custom message to an authentication exception... but
    it's never used! Instead, each class has a `getMessageKey()` method that returns
    a hard-coded explanation string. If you *do* need to send the user a very customized
    message, there *is* a special class for that called `CustomUserMessageAuthenticationException`
    that we'll talk about later.
  features:
    multiple_choice:
      choices:
        a: |
          The exception class would either be `UserNotFoundException` or `BadCredentialsException`
          based on whether or not you have `hide_user_not_found` in your `security.yaml`.
          The user would see `Get outta here Ryan!`
        b: |
          The exception class would either be `UserNotFoundException` or `BadCredentialsException`
          based on whether or not you have `hide_user_not_found` in your `security.yaml`.
          The user would see `Username could not be found.`
        c: |
          The `onAuthenticationFailure()` method would actually *not* be called because you
          can't throw that exception from directly inside `authenticate()`: you can only throw
          it from inside a "user loader" callback, like we have in the tutorial.
      correct: b
